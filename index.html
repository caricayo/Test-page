<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Fluid Simulation â€” pointer/touch interactive</title>
<style>
  :root{--bg:#0f1115;--ink:#e9eef7;--muted:#a9b4c2;--accent:#7aa2ff}
  html,body{height:100%}
  body{margin:0;background:radial-gradient(1200px 800px at 20% -10%, #1d2233 0%, #0f1115 60%);color:var(--ink);
        font-family:-apple-system,system-ui,Segoe UI,Roboto,Helvetica,Arial;display:grid;place-items:center}
  .wrap{width:min(95vw,1100px);padding:12px 14px 18px}
  h1{margin:.2rem 0 .6rem 0;font-size:1.25rem}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin-bottom:8px}
  .pill{appearance:none;border:1px solid rgba(255,255,255,.18);background:#1a2032;color:var(--ink);
        border-radius:999px;padding:8px 12px;font-size:.95rem}
  .muted{color:var(--muted);font-size:.92rem}
  canvas{display:block;width:100%;height:70vh;max-height:75vh;background:#0b0f17;border:1px solid rgba(255,255,255,.08);border-radius:12px}
</style>
</head>
<body>
<div class="wrap">
  <h1>Fluid Simulation (Stable Fluids, pointer-interactive)</h1>
  <div class="row">
    <button id="reset" class="pill">Reset</button>
    <label class="pill">Viscosity <input id="visc" type="range" min="0" max="0.005" step="0.0005" value="0.001" style="vertical-align:middle"></label>
    <label class="pill">Diffusion <input id="diff" type="range" min="0" max="0.005" step="0.0005" value="0.0008" style="vertical-align:middle"></label>
    <label class="pill">Force <input id="force" type="range" min="10" max="5000" step="10" value="1200" style="vertical-align:middle"></label>
    <span class="muted">Drag / swirl with mouse or finger. Pinch-zoom the page if you want a tighter brush.</span>
  </div>
  <canvas id="c"></canvas>
</div>

<script>
/* ====== Minimal Stable Fluids (Jos Stam) on a small grid ====== */
const N = 96;               // grid resolution (NxN). Increase for more detail
const ITER = 16;            // pressure solve iterations
const SIZE = (N+2)*(N+2);   // include boundary cells

// Fields
let dens = new Float32Array(SIZE),
    densPrev = new Float32Array(SIZE),
    u = new Float32Array(SIZE),
    v = new Float32Array(SIZE),
    uPrev = new Float32Array(SIZE),
    vPrev = new Float32Array(SIZE);

const IX = (x,y)=> (x + (N+2)*y);

function clear(arr){ arr.fill(0); }

// Boundary conditions
function set_bnd(b, x){
  for(let i=1;i<=N;i++){
    x[IX(0, i)]   = b===1 ? -x[IX(1, i)]   : x[IX(1, i)];
    x[IX(N+1, i)] = b===1 ? -x[IX(N, i)]   : x[IX(N, i)];
    x[IX(i, 0)]   = b===2 ? -x[IX(i, 1)]   : x[IX(i, 1)];
    x[IX(i, N+1)] = b===2 ? -x[IX(i, N)]   : x[IX(i, N)];
  }
  x[IX(0,0)]         = 0.5*(x[IX(1,0)]     + x[IX(0,1)]);
  x[IX(0,N+1)]       = 0.5*(x[IX(1,N+1)]   + x[IX(0,N)]);
  x[IX(N+1,0)]       = 0.5*(x[IX(N,0)]     + x[IX(N+1,1)]);
  x[IX(N+1,N+1)]     = 0.5*(x[IX(N,N+1)]   + x[IX(N+1,N)]);
}

function lin_solve(b, x, x0, a, c){
  const cRecip = 1.0/c;
  for(let k=0;k<ITER;k++){
    for(let j=1;j<=N;j++){
      for(let i=1;i<=N;i++){
        x[IX(i,j)] = (x0[IX(i,j)] + a*(x[IX(i-1,j)]+x[IX(i+1,j)]+x[IX(i,j-1)]+x[IX(i,j+1)]))*cRecip;
      }
    }
    set_bnd(b, x);
  }
}

function diffuse(b, x, x0, diff, dt){
  const a = dt*diff*N*N;
  lin_solve(b, x, x0, a, 1+4*a);
}

function advect(b, d, d0, u, v, dt){
  const dt0 = dt*N;
  for(let j=1;j<=N;j++){
    for(let i=1;i<=N;i++){
      let x = i - dt0*u[IX(i,j)];
      let y = j - dt0*v[IX(i,j)];
      if(x<0.5) x=0.5; if(x>N+0.5) x=N+0.5;
      if(y<0.5) y=0.5; if(y>N+0.5) y=N+0.5;
      let i0 = Math.floor(x), i1 = i0+1;
      let j0 = Math.floor(y), j1 = j0+1;
      const s1 = x - i0, s0 = 1-s1, t1 = y - j0, t0 = 1-t1;
      d[IX(i,j)] =
        s0*(t0*d0[IX(i0,j0)] + t1*d0[IX(i0,j1)]) +
        s1*(t0*d0[IX(i1,j0)] + t1*d0[IX(i1,j1)]);
    }
  }
  set_bnd(b, d);
}

function project(u, v, p, div){
  for(let j=1;j<=N;j++){
    for(let i=1;i<=N;i++){
      div[IX(i,j)] = -0.5*(u[IX(i+1,j)]-u[IX(i-1,j)] + v[IX(i,j+1)]-v[IX(i,j-1)])/N;
      p[IX(i,j)] = 0;
    }
  }
  set_bnd(0, div); set_bnd(0, p);
  lin_solve(0, p, div, 1, 4);
  for(let j=1;j<=N;j++){
    for(let i=1;i<=N;i++){
      u[IX(i,j)] -= 0.5*N*(p[IX(i+1,j)] - p[IX(i-1,j)]);
      v[IX(i,j)] -= 0.5*N*(p[IX(i,j+1)] - p[IX(i,j-1)]);
    }
  }
  set_bnd(1, u); set_bnd(2, v);
}

function vel_step(u,v,u0,v0,visc,dt){
  // add sources u0,v0 already added externally
  [u0,u] = [u,u0]; diffuse(1,u,u0,visc,dt);
  [v0,v] = [v,v0]; diffuse(2,v,v0,visc,dt);
  project(u,v,u0,v0);
  [u0,u] = [u,u0]; [v0,v] = [v,v0];
  advect(1,u,u0,u0,v0,dt); advect(2,v,v0,u0,v0,dt);
  project(u,v,u0,v0);
}

function dens_step(x,x0,u,v,diff,dt){
  [x0,x] = [x,x0]; diffuse(0,x,x0,diff,dt);
  [x0,x] = [x,x0]; advect(0,x,x0,u,v,dt);
}

// Rendering
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha:false });
function resize(){
  const r = canvas.getBoundingClientRect();
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  canvas.width = Math.floor(r.width * dpr);
  canvas.height = Math.floor(r.height * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
}
new ResizeObserver(resize).observe(canvas);

function renderDensity(){
  const w = canvas.clientWidth, h = canvas.clientHeight;
  const img = ctx.createImageData(w, h);
  for(let y=0;y<h;y++){
    const gy = Math.floor((y/h)*(N+2));
    for(let x=0;x<w;x++){
      const gx = Math.floor((x/w)*(N+2));
      const d = Math.min(1, dens[IX(gx,gy)]);
      const i = (y*w + x)*4;
      // pretty ink: map density to teal/blue
      img.data[i]   = 40 + 160*d;
      img.data[i+1] = 200 + 30*d;
      img.data[i+2] = 255;
      img.data[i+3] = Math.min(255, 20 + 235*d);
    }
  }
  ctx.putImageData(img, 0, 0);
}

// Pointer interaction
let isDown=false, pmx=0,pmy=0;
const viscEl = document.getElementById('visc');
const diffEl = document.getElementById('diff');
const forceEl = document.getElementById('force');

function toGrid(px,py){
  const rect = canvas.getBoundingClientRect();
  const x = (px-rect.left)/rect.width * (N+2);
  const y = (py-rect.top)/rect.height * (N+2);
  return {i: Math.max(1, Math.min(N, Math.floor(x))), j: Math.max(1, Math.min(N, Math.floor(y)))};
}

function addBlob(px,py, dx,dy){
  const {i,j} = toGrid(px,py);
  const f = +forceEl.value;
  uPrev[IX(i,j)] += dx * f / 6000;
  vPrev[IX(i,j)] += dy * f / 6000;
  densPrev[IX(i,j)] += 2.0; // ink strength
}

canvas.addEventListener('pointerdown', e=>{ isDown=true; pmx=e.clientX; pmy=e.clientY; addBlob(e.clientX,e.clientY,0,0); });
canvas.addEventListener('pointermove', e=>{
  if(!isDown) return;
  addBlob(e.clientX,e.clientY, e.clientX-pmx, e.clientY-pmy);
  pmx=e.clientX; pmy=e.clientY;
},{passive:true});
window.addEventListener('pointerup', ()=>{ isDown=false; });

// Reset button
document.getElementById('reset').addEventListener('click', ()=>{
  [dens,densPrev,u,v,uPrev,vPrev].forEach(clear);
});

// Main loop
let lastT = performance.now();
function tick(t){
  const dt = Math.min(0.033, (t-lastT)/1000); lastT = t;
  const visc = +viscEl.value, diff = +diffEl.value;

  vel_step(u,v,uPrev,vPrev,visc,dt);
  dens_step(dens,densPrev,u,v,diff,dt);

  // clear sources
  uPrev.fill(0); vPrev.fill(0); densPrev.fill(0);

  renderDensity();
  requestAnimationFrame(tick);
}
resize(); requestAnimationFrame(tick);
</script>
</body>
</html>
